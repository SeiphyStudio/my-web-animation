<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高中物理模擬實驗室：動量與碰撞</title>
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --text-color: #f8fafc;
            --accent-color: #10b981;
            --tab-inactive: #334155;
            --danger-color: #ef4444;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* 頂部導航與分頁 */
        .nav-header {
            width: 100%;
            background-color: rgba(30, 41, 59, 0.95);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            padding-top: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        h1 { margin: 0 0 1rem 0; font-size: 1.5rem; letter-spacing: 1px; }

        .tabs {
            display: flex;
            gap: 5px;
            width: 100%;
            max-width: 1000px;
            padding: 0 20px;
        }

        .tab-btn {
            background-color: var(--tab-inactive);
            color: #94a3b8;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            max-width: 200px;
        }

        .tab-btn:hover { background-color: #475569; color: white; }
        
        .tab-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 -2px 10px rgba(59, 130, 246, 0.3);
        }

        /* 主內容區域 */
        .container {
            width: 100%;
            max-width: 1000px;
            padding: 20px;
            display: none; /* 預設隱藏，透過 JS 切換 */
            flex-direction: column;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .container.active { display: flex; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Canvas 通用樣式 */
        .canvas-wrapper {
            position: relative;
            border-radius: 0 0 12px 12px; /* 配合上方無圓角 */
            overflow: hidden;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
            background: radial-gradient(circle at center, #475569 0%, #1e293b 100%);
            margin-bottom: 20px;
            border: 1px solid #475569;
            width: 100%;
            max-width: 100%;
        }
        
        /* 為了讓第一個分頁的 Canvas 也有圓角 (如果不需要貼合 Tab) */
        .tab-content .canvas-wrapper { border-radius: 12px; }

        canvas { display: block; width: 100%; height: auto; }

        /* 控制面板通用樣式 */
        .controls {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            display: grid;
            gap: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }

        /* 兩欄佈局 */
        .grid-2 { grid-template-columns: 1fr 1fr; }
        
        /* 參數滑桿 */
        .slider-group {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            color: #cbd5e1;
            font-size: 0.9rem;
            font-weight: bold;
        }

        input[type=range] { width: 100%; cursor: pointer; margin-top: 5px; }

        /* 開關樣式 */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            background: rgba(16, 185, 129, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--accent-color);
            font-weight: bold;
            margin-top: 10px;
        }
        .toggle-switch input { width: 20px; height: 20px; }

        /* 動作按鈕懸浮區 */
        .actions-overlay {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .btn-action {
            pointer-events: auto;
            padding: 10px 30px;
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            transition: transform 0.1s;
        }
        .btn-action:hover { transform: translateY(-2px); filter: brightness(110%); }
        .btn-action:active { transform: translateY(0); }
        .btn-action:disabled { opacity: 0.6; cursor: not-allowed; transform: none; background-color: #64748b; }

        .btn-start { background-color: rgba(16, 185, 129, 0.9); color: white; }
        .btn-reset { background-color: rgba(239, 68, 68, 0.9); color: white; }

        /* 數據顯示 - 左上角 (速度) */
        .data-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.9);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 2.5rem; /* 放大 2.5 倍 */
            font-weight: bold;
            pointer-events: none;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.2;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        /* 數據顯示 - 右上角 (質量) */
        .data-display-right {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.9);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 2.5rem; /* 保持一致的大小 */
            font-weight: bold;
            text-align: right;
            pointer-events: none;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.2;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        /* 原有牛頓擺的特定樣式保留 */
        .btn-group { display: flex; gap: 8px; background: #0f172a; padding: 5px; border-radius: 8px; justify-content: center;}
        .btn-select { background: transparent; border: none; color: #94a3b8; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 1.1rem; }
        .btn-select.active { background-color: var(--primary-color); color: white; }

        @media (max-width: 600px) {
            .grid-2 { grid-template-columns: 1fr; }
            .tabs { padding: 0 10px; }
            .tab-btn { font-size: 0.9rem; padding: 10px; }
            .data-display, .data-display-right { font-size: 1.5rem; padding: 10px; } /* 手機版字體縮小 */
        }
    </style>
</head>
<body>

<div class="nav-header">
    <h1>高中物理模擬實驗室</h1>
    <div class="tabs">
        <!-- 分頁名稱修改 -->
        <button class="tab-btn active" onclick="switchTab('linear')">實驗一：直線碰撞</button>
        <button class="tab-btn" onclick="switchTab('cradle')">實驗二：牛頓擺</button>
    </div>
</div>

<!-- ================= 實驗一：直線彈性碰撞 ================= -->
<div id="tab-linear" class="container active">
    <div class="canvas-wrapper">
        <canvas id="linearCanvas" width="800" height="400"></canvas>
        
        <!-- 左上角：速度顯示 -->
        <div class="data-display" id="linearData">
            v1: 0.0 m/s<br>v2: 0.0 m/s
        </div>
        
        <!-- 右上角：質量顯示 -->
        <div class="data-display-right" id="linearMass">
            m1: 2.0 kg<br>m2: 2.0 kg
        </div>

        <div class="actions-overlay">
            <button class="btn-action btn-start" id="btnLinearStart" onclick="linearSim.start()">
                <span>▶ 發射 (Fire)</span>
            </button>
            <button class="btn-action btn-reset" id="btnLinearReset" onclick="linearSim.reset()" disabled>
                <span>↺ 重置 (Reset)</span>
            </button>
        </div>
    </div>

    <div class="controls grid-2">
        <!-- 左側：m1 設定 -->
        <div class="slider-group">
            <div class="slider-header">
                <span>鋼球 1 質量 (m1)</span>
                <span id="valM1">2.0 kg</span>
            </div>
            <input type="range" id="rangeM1" min="1" max="10" step="0.5" value="2" oninput="linearSim.updateParams()">
            
            <!-- m1 無限大開關 -->
            <label class="toggle-switch">
                <input type="checkbox" id="checkInfiniteM1" onchange="linearSim.updateParams('m1')">
                <span>m1 質量無限大</span>
            </label>

            <div class="slider-header" style="margin-top:10px;">
                <span>鋼球 1 初速 (v1)</span>
                <span id="valV1">5.0 m/s</span>
            </div>
            <input type="range" id="rangeV1" min="1" max="10" step="0.5" value="5" oninput="linearSim.updateParams()">
        </div>

        <!-- 右側：m2 設定 -->
        <div class="slider-group">
            <div class="slider-header">
                <span>鋼球 2 質量 (m2)</span>
                <span id="valM2">2.0 kg</span>
            </div>
            <input type="range" id="rangeM2" min="1" max="10" step="0.5" value="2" oninput="linearSim.updateParams()">
            
            <!-- m2 無限大開關 -->
            <label class="toggle-switch">
                <input type="checkbox" id="checkInfiniteM2" onchange="linearSim.updateParams('m2')">
                <span>m2 質量無限大</span>
            </label>
            <div style="font-size:0.8rem; color:#94a3b8; margin-top:5px;">
                * 預設 m2 初速為 0 (靜止)
            </div>
        </div>

        <!-- 新增：恢復係數 (跨欄顯示) -->
        <div class="slider-group" style="grid-column: 1 / -1;">
            <div class="slider-header">
                <span>恢復係數 (Coefficient of Restitution, e)</span>
                <span id="linearRestitutionVal">1.00</span>
            </div>
            <input type="range" id="linearRestitutionRange" min="0" max="1" step="0.01" value="1.0" oninput="linearSim.updateParams()">
            <div style="font-size: 0.85rem; color: #64748b; margin-top: 5px;">0 = 完全非彈性 | 1 = 完全彈性</div>
        </div>
    </div>
</div>

<!-- ================= 實驗二：牛頓擺 ================= -->
<div id="tab-cradle" class="container">
    <div class="canvas-wrapper">
        <canvas id="cradleCanvas" width="800" height="500"></canvas>
        <div class="actions-overlay">
            <button class="btn-action btn-start" id="btnCradleStart" onclick="cradleSim.start()">
                <span>▶ 開始實驗</span>
            </button>
            <button class="btn-action btn-reset" id="btnCradleReset" onclick="cradleSim.reset()" disabled>
                <span>↺ 重置實驗</span>
            </button>
        </div>
    </div>

    <div class="controls">
        <div class="grid-2">
            <!-- 左側拉起 -->
            <div style="text-align:center;">
                <div style="margin-bottom:10px; color:#cbd5e1; font-weight:bold;">左側拉起數量</div>
                <div class="btn-group" id="leftBtns">
                    <button class="btn-select active" onclick="cradleSim.setLeft(0)">0</button>
                    <button class="btn-select" onclick="cradleSim.setLeft(1)">1</button>
                    <button class="btn-select" onclick="cradleSim.setLeft(2)">2</button>
                    <button class="btn-select" onclick="cradleSim.setLeft(3)">3</button>
                    <button class="btn-select" onclick="cradleSim.setLeft(4)">4</button>
                </div>
            </div>
            <!-- 右側拉起 -->
            <div style="text-align:center;">
                <div style="margin-bottom:10px; color:#cbd5e1; font-weight:bold;">右側拉起數量</div>
                <div class="btn-group" id="rightBtns">
                    <button class="btn-select active" onclick="cradleSim.setRight(0)">0</button>
                    <button class="btn-select" onclick="cradleSim.setRight(1)">1</button>
                    <button class="btn-select" onclick="cradleSim.setRight(2)">2</button>
                    <button class="btn-select" onclick="cradleSim.setRight(3)">3</button>
                    <button class="btn-select" onclick="cradleSim.setRight(4)">4</button>
                </div>
            </div>
        </div>
        
        <!-- 恢復係數 -->
        <div class="slider-group">
            <div class="slider-header">
                <span>恢復係數 (e)</span>
                <span id="restitutionVal">1.00</span>
            </div>
            <input type="range" id="restitutionRange" min="0" max="1" step="0.01" value="1.0" oninput="cradleSim.updateRestitution(this.value)">
            <div style="font-size: 0.85rem; color: #64748b; margin-top: 5px;">0 = 完全非彈性 | 1 = 完全彈性</div>
        </div>
    </div>
</div>

<script>
// ==================== 頁面切換邏輯 ====================
function switchTab(tabName) {
    // 隱藏所有
    document.querySelectorAll('.container').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
    
    // 停止所有動畫以節省效能
    linearSim.stopLoop();
    cradleSim.stopLoop();

    // 顯示選定
    document.getElementById(`tab-${tabName}`).classList.add('active');
    // 更新按鈕狀態 (簡單遍歷)
    const btns = document.querySelectorAll('.tab-btn');
    if(tabName === 'linear') {
        btns[0].classList.add('active');
        linearSim.loop(); // 啟動 Loop 但不一定是模擬中
    } else {
        btns[1].classList.add('active');
        cradleSim.loop();
    }
}

// ==================== 實驗一：直線碰撞 邏輯 ====================
const linearSim = (function() {
    const canvas = document.getElementById('linearCanvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let isRunning = false;
    
    // 物理參數
    let params = {
        m1: 2,
        v1: 5,
        m2: 2,
        v2: 0,
        isM1Infinite: false,
        isM2Infinite: false,
        restitution: 1.0 // 新增：恢復係數
    };

    // 球體物件
    let b1 = { x: 100, v: 0, m: 0, r: 25, color: '#3b82f6' };
    let b2 = { x: 500, v: 0, m: 0, r: 25, color: '#ef4444' };

    // 固定半徑，不隨質量改變
    const FIXED_RADIUS = 30;

    function init() {
        updateParams();
        reset();
        loop();
    }

    function updateParams(source) {
        // 互斥邏輯
        const checkM1 = document.getElementById('checkInfiniteM1');
        const checkM2 = document.getElementById('checkInfiniteM2');

        if (source === 'm1' && checkM1.checked) {
            checkM2.checked = false;
        } else if (source === 'm2' && checkM2.checked) {
            checkM1.checked = false;
        }

        const rangeM1 = document.getElementById('rangeM1');
        const rangeM2 = document.getElementById('rangeM2');
        
        params.isM1Infinite = checkM1.checked;
        params.isM2Infinite = checkM2.checked;

        // 處理 m1
        if (params.isM1Infinite) {
            rangeM1.disabled = true;
            document.getElementById('valM1').textContent = "∞";
            params.m1 = Infinity;
        } else {
            rangeM1.disabled = false;
            params.m1 = parseFloat(rangeM1.value);
            document.getElementById('valM1').textContent = params.m1.toFixed(1) + " kg";
        }

        // 處理 m2
        if (params.isM2Infinite) {
            rangeM2.disabled = true;
            document.getElementById('valM2').textContent = "∞";
            params.m2 = Infinity;
        } else {
            rangeM2.disabled = false;
            params.m2 = parseFloat(rangeM2.value);
            document.getElementById('valM2').textContent = params.m2.toFixed(1) + " kg";
        }

        params.v1 = parseFloat(document.getElementById('rangeV1').value);
        document.getElementById('valV1').textContent = params.v1.toFixed(1) + " m/s";

        // 處理恢復係數
        const rangeE = document.getElementById('linearRestitutionRange');
        params.restitution = parseFloat(rangeE.value);
        document.getElementById('linearRestitutionVal').textContent = params.restitution.toFixed(2);

        // 更新球體質量 (若未開始)
        if (!isRunning) {
            b1.m = params.m1;
            b2.m = params.m2;
            b1.r = FIXED_RADIUS;
            b2.r = FIXED_RADIUS;
            updateDisplay(); // 即時更新顯示數據
        }
    }

    function reset() {
        isRunning = false;
        b1.x = 100;
        b1.v = 0; 
        b1.m = params.m1;
        b1.r = FIXED_RADIUS;

        b2.x = 500;
        b2.v = 0;
        b2.m = params.m2;
        b2.r = FIXED_RADIUS;

        document.getElementById('btnLinearStart').disabled = false;
        document.getElementById('btnLinearReset').disabled = true;
        
        // 介面控制項解鎖 (根據開關狀態)
        const rangeM1 = document.getElementById('rangeM1');
        const rangeM2 = document.getElementById('rangeM2');
        
        rangeM1.disabled = params.isM1Infinite;
        rangeM2.disabled = params.isM2Infinite;
        
        document.getElementById('rangeV1').disabled = false;
        document.getElementById('checkInfiniteM1').disabled = false;
        document.getElementById('checkInfiniteM2').disabled = false;
        document.getElementById('linearRestitutionRange').disabled = false; // 解鎖 e

        draw();
        updateDisplay();
    }

    function start() {
        if (isRunning) return;
        isRunning = true;
        
        // 賦予初速
        b1.v = params.v1; 
        
        document.getElementById('btnLinearStart').disabled = true;
        document.getElementById('btnLinearReset').disabled = false;

        // 鎖定所有參數
        document.getElementById('rangeM1').disabled = true;
        document.getElementById('rangeM2').disabled = true;
        document.getElementById('rangeV1').disabled = true;
        document.getElementById('checkInfiniteM1').disabled = true;
        document.getElementById('checkInfiniteM2').disabled = true;
        document.getElementById('linearRestitutionRange').disabled = true; // 鎖定 e
    }

    function update() {
        if (!isRunning) return;

        const timeScale = 2; 
        b1.x += b1.v * timeScale;
        b2.x += b2.v * timeScale;

        // 碰撞偵測
        if (b1.x + b1.r + b2.r >= b2.x) {
            // 發生碰撞，位置修正
            let overlap = (b1.x + b1.r + b2.r) - b2.x;
            
            // 如果質量無限大，位置不應該被推動(或推動別人)，這裡簡單平均分配修正以免穿透
            // 若其中一個無限大，則該物體不動，另一物體全額修正
            if (params.isM1Infinite && !params.isM2Infinite) {
                b2.x += overlap;
            } else if (!params.isM1Infinite && params.isM2Infinite) {
                b1.x -= overlap;
            } else {
                b1.x -= overlap / 2;
                b2.x += overlap / 2;
            }

            // 速度計算
            let v1 = b1.v;
            let v2 = b2.v;
            let m1 = params.m1; 
            let m2 = params.m2;
            let e = params.restitution; // 恢復係數

            let v1_new, v2_new;

            // 處理無限大的情況
            if (m1 === Infinity && m2 === Infinity) {
                // 兩個都無限大 - 簡單反彈
                v1_new = -e * v1;
                v2_new = -e * v2; 
            } else if (m1 === Infinity) {
                // m1 是無限大
                // v1' = v1
                // v2' = v1 + e(v1 - v2)
                v1_new = v1;
                v2_new = v1 + e * (v1 - v2);
            } else if (m2 === Infinity) {
                // m2 是無限大 (如球撞牆)
                // v2' = v2
                // v1' = v2 - e(v1 - v2)
                v2_new = v2;
                v1_new = v2 - e * (v1 - v2);
            } else {
                // 一般情況 (含恢復係數的一維碰撞公式)
                // v1' = [ (m1 - e*m2)v1 + (1+e)m2v2 ] / (m1 + m2)
                // v2' = [ (1+e)m1v1 + (m2 - e*m1)v2 ] / (m1 + m2)
                // 或者寫成:
                // v1' = (m1*v1 + m2*v2 - m2*e*(v1 - v2)) / (m1 + m2)
                // v2' = (m1*v1 + m2*v2 + m1*e*(v1 - v2)) / (m1 + m2)
                
                let commonTerm = m1 * v1 + m2 * v2; // 總動量(碰撞前) - 但若非彈性不一定守恆? 不對，動量永遠守恆(外力為0)
                // 修正：動量守恆是 m1v1 + m2v2 = m1v1' + m2v2'
                // 恢復係數定義: v2' - v1' = e(v1 - v2)
                
                v1_new = (m1 * v1 + m2 * v2 - m2 * e * (v1 - v2)) / (m1 + m2);
                v2_new = (m1 * v1 + m2 * v2 + m1 * e * (v1 - v2)) / (m1 + m2);
            }

            b1.v = v1_new;
            b2.v = v2_new;
        }
        
        updateDisplay();
    }

    function updateDisplay() {
        // 更新速度
        const textV = `v1: ${b1.v.toFixed(2)} m/s<br>v2: ${b2.v.toFixed(2)} m/s`;
        document.getElementById('linearData').innerHTML = textV;

        // 更新質量
        let m1Text = params.isM1Infinite ? "∞" : params.m1.toFixed(1) + " kg";
        let m2Text = params.isM2Infinite ? "∞" : params.m2.toFixed(1) + " kg";
        const textM = `m1: ${m1Text}<br>m2: ${m2Text}`;
        document.getElementById('linearMass').innerHTML = textM;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 地板
        ctx.beginPath();
        ctx.moveTo(0, 300);
        ctx.lineTo(800, 300);
        ctx.strokeStyle = "#94a3b8";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 繪製球體
        // 標籤顯示判斷
        let label1 = params.isM1Infinite ? "∞" : "m1";
        let label2 = params.isM2Infinite ? "∞" : "m2";

        drawBall(b1.x, 300 - b1.r, b1.r, b1.color, label1);
        drawBall(b2.x, 300 - b2.r, b2.r, b2.color, label2);
    }

    function drawBall(x, y, r, color, label) {
        // 陰影
        ctx.beginPath();
        ctx.ellipse(x, 300 + 5, r, r * 0.2, 0, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fill();

        // 球體
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        let grad = ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.3, color);
        grad.addColorStop(1, "#0f172a");
        ctx.fillStyle = grad;
        ctx.fill();

        // 標籤
        ctx.fillStyle = "#fff";
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.fillText(label, x, y + 6);
    }

    function loop() {
        update();
        draw();
        animationId = requestAnimationFrame(loop);
    }

    function stopLoop() {
        cancelAnimationFrame(animationId);
    }

    return { init, updateParams, start, reset, loop, stopLoop };
})();

// ==================== 實驗二：牛頓擺 邏輯 (保留原功能) ====================
const cradleSim = (function() {
    const CONFIG = {
        gravity: 0.4, damping: 0.999, ballRadius: 25, stringLen: 280,
        topY: 100, centerX: 400, pullAngle: Math.PI / 4
    };
    
    let canvas, ctx, balls = [], isSimulating = false, animationId;
    let leftCount = 0, rightCount = 0, restitution = 1.0;

    class Ball {
        constructor(id, xOrigin, yOrigin) {
            this.id = id;
            this.origin = { x: xOrigin, y: yOrigin };
            this.angle = 0; this.aVelocity = 0; this.aAcceleration = 0;
            this.updatePosition();
        }
        updatePosition() {
            this.x = this.origin.x + Math.sin(this.angle) * CONFIG.stringLen;
            this.y = this.origin.y + Math.cos(this.angle) * CONFIG.stringLen;
        }
        update(dt) {
            if (!isSimulating) return;
            this.aAcceleration = (-1 * CONFIG.gravity / CONFIG.stringLen) * Math.sin(this.angle);
            this.aVelocity += this.aAcceleration * dt;
            let currentDamping = (restitution >= 1.0) ? 1.0 : CONFIG.damping;
            this.aVelocity *= currentDamping;
            this.angle += this.aVelocity * dt;
            this.updatePosition();
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.moveTo(this.origin.x, this.origin.y);
            ctx.lineTo(this.x, this.y);
            ctx.strokeStyle = "rgba(200, 200, 200, 0.5)";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Ball Drawing (Simplified for brevity as style is same)
            let grad = ctx.createRadialGradient(this.x - 8, this.y - 8, 3, this.x, this.y, CONFIG.ballRadius);
            grad.addColorStop(0, "#f1f5f9"); grad.addColorStop(0.3, "#cbd5e1"); grad.addColorStop(1, "#334155");
            ctx.beginPath(); ctx.arc(this.x, this.y, CONFIG.ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = grad; ctx.fill();
        }
    }

    function init() {
        canvas = document.getElementById('cradleCanvas');
        ctx = canvas.getContext('2d');
        let startX = CONFIG.centerX - 2 * (CONFIG.ballRadius * 2) + CONFIG.ballRadius; // Centering logic
        balls = [];
        for (let i = 0; i < 5; i++) {
            balls.push(new Ball(i, CONFIG.centerX + (i-2) * CONFIG.ballRadius * 2, CONFIG.topY));
        }
        updateUI();
        draw();
    }

    function applySetup() {
        isSimulating = false;
        balls.forEach(b => { b.angle = 0; b.aVelocity = 0; b.updatePosition(); });
        for(let i=0; i<leftCount; i++) balls[i].angle = -CONFIG.pullAngle;
        for(let i=0; i<rightCount; i++) balls[balls.length - 1 - i].angle = CONFIG.pullAngle;
        balls.forEach(b => b.updatePosition());
        draw();
    }

    function checkCollisions() {
        let e = restitution;
        for (let i = 0; i < balls.length - 1; i++) {
            let b1 = balls[i], b2 = balls[i+1];
            let dist = Math.sqrt((b2.x-b1.x)**2 + (b2.y-b1.y)**2);
            if (dist < CONFIG.ballRadius * 2) {
                let v1 = b1.aVelocity, v2 = b2.aVelocity;
                b1.aVelocity = (v1 * (1 - e) + v2 * (1 + e)) / 2;
                b2.aVelocity = (v1 * (1 + e) + v2 * (1 - e)) / 2;
                
                // Anti-stick push
                let overlap = CONFIG.ballRadius * 2 - dist;
                let push = (overlap / CONFIG.stringLen) * 0.5;
                if(b1.angle > b2.angle) { let t=b1.angle; b1.angle=b2.angle; b2.angle=t; }
                else { b1.angle -= push; b2.angle += push; }
            }
        }
    }

    function update() {
        if (!isSimulating) return;
        const steps = 4;
        for(let s=0; s<steps; s++) {
            balls.forEach(b => b.update(1/steps));
            checkCollisions();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 36px 'Segoe UI', sans-serif";
        ctx.fillStyle = "#cbd5e1"; ctx.textAlign = "center";
        ctx.fillText("牛頓擺", CONFIG.centerX, CONFIG.topY - 40);
        
        ctx.beginPath(); ctx.moveTo(balls[0].origin.x - 20, CONFIG.topY);
        ctx.lineTo(balls[4].origin.x + 20, CONFIG.topY);
        ctx.strokeStyle = "#94a3b8"; ctx.lineWidth = 6; ctx.lineCap = "round"; ctx.stroke();
        
        balls.forEach(b => b.draw(ctx));
    }

    function loop() {
        update();
        draw();
        animationId = requestAnimationFrame(loop);
    }
    
    function stopLoop() { cancelAnimationFrame(animationId); }

    // Public API
    function start() { isSimulating = true; updateUI(); }
    function reset() { isSimulating = false; applySetup(); updateUI(); }
    function setLeft(n) { if(isSimulating) return; if(n+rightCount>5) rightCount=5-n; leftCount=n; applySetup(); updateUI(); }
    function setRight(n) { if(isSimulating) return; if(n+leftCount>5) leftCount=5-n; rightCount=n; applySetup(); updateUI(); }
    function updateRestitution(val) { 
        restitution = parseFloat(val); 
        document.getElementById('restitutionVal').textContent = restitution.toFixed(2);
    }
    function updateUI() {
        document.getElementById('btnCradleStart').disabled = isSimulating;
        document.getElementById('btnCradleReset').disabled = !isSimulating;
        document.querySelectorAll('#leftBtns button').forEach((b,i) => b.className = i===leftCount?'btn-select active':'btn-select');
        document.querySelectorAll('#rightBtns button').forEach((b,i) => b.className = i===rightCount?'btn-select active':'btn-select');
        const disable = isSimulating;
        document.querySelectorAll('#tab-cradle .btn-select').forEach(b => b.disabled = disable);
    }

    return { init, start, reset, setLeft, setRight, updateRestitution, loop, stopLoop };
})();

// ==================== 初始化 ====================
window.onload = function() {
    linearSim.init();
    cradleSim.init();
    // 預設啟動 Tab 1
    switchTab('linear');
};
</script>

</body>
</html>