<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>絲滑版小精靈：向量追擊物理模擬</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        canvas { border: 2px solid #00d2ff; background-color: #0a0a16; box-shadow: 0 0 30px rgba(0, 210, 255, 0.15); border-radius: 4px; }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(16, 16, 32, 0.85);
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            z-index: 100;
            width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h2 { margin-top: 0; color: #00d2ff; text-transform: uppercase; font-size: 1.1rem; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #aaffaa; font-size: 0.85rem; }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: #444;
            outline: none;
            border-radius: 2px;
            margin-top: 5px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d2ff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #00d2ff;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        #score-board, #timer-board {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;
        }
        #score { color: #ffcc00; font-size: 1.4em; font-weight: bold; text-shadow: 0 0 5px rgba(255, 204, 0, 0.5); }
        #timer { color: #00d2ff; font-size: 1.4em; font-weight: bold; font-family: monospace; text-shadow: 0 0 5px rgba(0, 210, 255, 0.5); }
        #game-status { color: #ff4d4d; font-weight: bold; font-size: 1.1em; min-height: 2.5em; text-align: center; margin-top: 15px; text-shadow: 0 0 10px red; line-height: 1.4;}
        .instruction { font-size: 0.75rem; color: #888; margin-top: 4px; font-style: italic; }
        .key-badge { background: #333; padding: 2px 6px; border-radius: 4px; color: #fff; font-family: monospace; }
        .status-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-bottom: 5px;}
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <h2>物理參數控制面板</h2>
        
        <div class="control-group">
            <label>小精靈速度 (Velocity)</label>
            <input type="range" id="speedSlider" min="1.5" max="5" value="2.5" step="0.1">
        </div>

        <div class="control-group">
            <label>幽靈感知半徑 (Field of View)</label>
            <input type="range" id="ghostRangeSlider" min="50" max="400" value="150" step="10">
            <div class="instruction">進入此圓圈後，幽靈會開始追擊</div>
        </div>

        <div class="control-group">
            <label>幽靈速度 (Ghost Speed)</label>
            <input type="range" id="ghostSpeedSlider" min="0.5" max="3" value="1.5" step="0.1">
        </div>

        <div id="score-board">
            <span>SCORE</span>
            <span id="score">0</span>
        </div>
        
        <div id="timer-board">
            <span>TIME</span>
            <span id="timer">00:00</span>
        </div>

        <div id="game-status"></div>
        <div class="instruction" style="text-align: center; margin-top: 15px; border-top: 1px solid #333; padding-top:10px;">
            使用 <span class="key-badge">方向鍵</span> 控制向量方向
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布設定
        canvas.width = 600;
        canvas.height = 600;
        const GRID_SIZE = 30; 

        // 霓虹配色表
        const COLORS = {
            wall: '#0f0f20',
            wallBorder: '#1e3c72',
            wallGlow: 'rgba(30, 60, 114, 0.3)',
            pacman: '#ffff00',
            pellet: '#ffcc00',
            powerPellet: '#ff00ff', // 無敵星星顏色
            trail: 'rgba(5, 5, 16, 0.25)', // 殘影清除顏色
            // 幽靈顏色定義
            ghostRed: '#ff3333',
            ghostYellow: '#ffcc00', 
            ghostGreen: '#33ff33',
            ghostScared: '#4444ff', // 被嚇到的藍色
            rangeIndicator: 'rgba(255, 0, 85, 0.1)'
        };

        // 遊戲核心變數
        let score = 0;
        let gameOver = false;
        let gameWin = false;
        let totalPellets = 0;
        let animationId;
        let startTime = Date.now(); 
        
        // 無敵模式狀態
        let powerModeEndTime = 0;

        // 地圖定義 (1:牆, 0:空, 2:豆子, 3:無敵星星)
        // 調整星星位置：避開左上角出生點，改為放在內圈
        const initialMaze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1], // Row 1: 恢復為普通豆子 (Pacman出生點在左上)
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1], // Row 2
            [1,3,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,3,1], // Row 3: 新增無敵星星 (兩側)
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1], // Row 4
            [1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,1,1],
            [1,1,1,1,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1],
            [1,1,1,1,2,1,2,1,1,0,0,1,1,2,1,2,1,1,1,1],
            [1,1,1,1,2,1,2,1,0,0,0,0,1,2,1,2,1,1,1,1], 
            [1,1,1,1,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1],
            [1,1,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1], 
            [1,3,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,3,1], // Row 15: 新增無敵星星 (兩側)
            [1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1], 
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1], // Row 17: 恢復為普通豆子
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let maze = JSON.parse(JSON.stringify(initialMaze));
        // 計算總豆子數 (2和3都算)
        totalPellets = maze.flat().filter(c => c === 2 || c === 3).length;

        // 物理物件
        const pacman = {
            x: GRID_SIZE * 1.5,
            y: GRID_SIZE * 1.5,
            radius: 12,
            speed: 2.5,
            dx: 0,
            dy: 0,
            nextDx: 0,
            nextDy: 0,
            angle: 0,
            mouthOpen: 0,
            mouthSpeed: 0.2
        };

        // 幽靈設定：加入出生點紀錄與復活時間
        const ghosts = [
            { x: GRID_SIZE * 9.5, y: GRID_SIZE * 8.5, startX: GRID_SIZE * 9.5, startY: GRID_SIZE * 8.5, originalColor: COLORS.ghostRed, color: COLORS.ghostRed, dx: 1, dy: 0, speed: 1.5, state: 'wander', isDead: false, reviveTime: 0 },
            { x: GRID_SIZE * 10.5, y: GRID_SIZE * 8.5, startX: GRID_SIZE * 10.5, startY: GRID_SIZE * 8.5, originalColor: COLORS.ghostYellow, color: COLORS.ghostYellow, dx: -1, dy: 0, speed: 1.5, state: 'wander', isDead: false, reviveTime: 0 },
            { x: GRID_SIZE * 9.5, y: GRID_SIZE * 10.5, startX: GRID_SIZE * 9.5, startY: GRID_SIZE * 10.5, originalColor: COLORS.ghostGreen, color: COLORS.ghostGreen, dx: 0, dy: -1, speed: 1.5, state: 'wander', isDead: false, reviveTime: 0 }
        ];

        let ghostDetectionRadius = 150;

        // UI 綁定
        const speedSlider = document.getElementById('speedSlider');
        const ghostRangeSlider = document.getElementById('ghostRangeSlider');
        const ghostSpeedSlider = document.getElementById('ghostSpeedSlider');
        const scoreDisplay = document.getElementById('score');
        const timerDisplay = document.getElementById('timer');
        const statusDisplay = document.getElementById('game-status');

        speedSlider.addEventListener('input', (e) => pacman.speed = parseFloat(e.target.value));
        ghostRangeSlider.addEventListener('input', (e) => ghostDetectionRadius = parseFloat(e.target.value));
        ghostSpeedSlider.addEventListener('input', (e) => ghosts.forEach(g => g.speed = parseFloat(e.target.value)));

        // 鍵盤控制
        document.addEventListener('keydown', (e) => {
            if(gameOver || gameWin) return;
            switch(e.key) {
                case 'ArrowUp': pacman.nextDx = 0; pacman.nextDy = -1; break;
                case 'ArrowDown': pacman.nextDx = 0; pacman.nextDy = 1; break;
                case 'ArrowLeft': pacman.nextDx = -1; pacman.nextDy = 0; break;
                case 'ArrowRight': pacman.nextDx = 1; pacman.nextDy = 0; break;
            }
        });

        // --- 核心物理邏輯 ---

        function isWallGrid(c, r) {
            if (r < 0 || r >= maze.length || c < 0 || c >= maze[0].length) return true;
            return maze[r][c] === 1;
        }

        function isWallPixel(x, y, radius) {
            const points = [
                {x: x - radius, y: y}, {x: x + radius, y: y},
                {x: x, y: y - radius}, {x: x, y: y + radius} 
            ];
            for (let p of points) {
                const col = Math.floor(p.x / GRID_SIZE);
                const row = Math.floor(p.y / GRID_SIZE);
                if (isWallGrid(col, row)) return true;
            }
            return false;
        }

        function getCenter(val) {
            return Math.floor(val / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        }

        function updateTimer() {
            if(gameOver || gameWin) return;
            const now = Date.now();
            const elapsed = now - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            const formattedTime = (minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            timerDisplay.innerText = formattedTime;
        }

        function activatePowerMode() {
            powerModeEndTime = Date.now() + 5000; // 5秒
            statusDisplay.innerHTML = '<span class="status-badge" style="background:#0000ff; color:white;">無敵模式! 追擊幽靈!</span>';
            
            ghosts.forEach(g => {
                if (!g.isDead) {
                    g.state = 'scared';
                    // 立即反向逃跑
                    const reverseDx = -g.dx;
                    const reverseDy = -g.dy;
                    // 檢查反向是否撞牆，如果沒撞牆才反向，不然交給AI判斷
                    const gridX = Math.round(g.x / GRID_SIZE - 0.5);
                    const gridY = Math.round(g.y / GRID_SIZE - 0.5);
                    if (!isWallGrid(gridX + reverseDx, gridY + reverseDy)) {
                        g.dx = reverseDx;
                        g.dy = reverseDy;
                    }
                }
            });
        }

        function updatePacman() {
            if (gameOver || gameWin) return;

            const centerX = getCenter(pacman.x);
            const centerY = getCenter(pacman.y);
            const distToCenter = Math.hypot(pacman.x - centerX, pacman.y - centerY);

            if (distToCenter < 5) {
                if (pacman.nextDx !== 0 || pacman.nextDy !== 0) {
                    const nextCol = Math.floor((centerX + pacman.nextDx * GRID_SIZE) / GRID_SIZE);
                    const nextRow = Math.floor((centerY + pacman.nextDy * GRID_SIZE) / GRID_SIZE);
                    
                    if (!isWallGrid(nextCol, nextRow)) {
                        pacman.x = centerX; 
                        pacman.y = centerY;
                        pacman.dx = pacman.nextDx;
                        pacman.dy = pacman.nextDy;
                        pacman.nextDx = 0; 
                        pacman.nextDy = 0;
                    }
                }
            }

            let nextX = pacman.x + pacman.dx * pacman.speed;
            let nextY = pacman.y + pacman.dy * pacman.speed;

            if (!isWallPixel(nextX, nextY, pacman.radius - 2)) {
                pacman.x = nextX;
                pacman.y = nextY;
            } else {
                pacman.x = centerX; 
                pacman.y = centerY; 
            }

            // 吃豆子與星星檢測
            const col = Math.floor(pacman.x / GRID_SIZE);
            const row = Math.floor(pacman.y / GRID_SIZE);
            const cellType = maze[row][col];

            if (cellType === 2 || cellType === 3) {
                const itemX = col * GRID_SIZE + GRID_SIZE/2;
                const itemY = row * GRID_SIZE + GRID_SIZE/2;
                if (Math.hypot(pacman.x - itemX, pacman.y - itemY) < 10) {
                    maze[row][col] = 0;
                    score++;
                    
                    // 如果吃到無敵星星
                    if (cellType === 3) {
                        activatePowerMode();
                    }

                    scoreDisplay.innerText = score;
                    
                    // 檢查剩餘豆子
                    const remaining = maze.flat().filter(c => c === 2 || c === 3).length;
                    if (remaining === 0) {
                        gameWin = true;
                        const finalTime = timerDisplay.innerText;
                        statusDisplay.innerHTML = `恭喜過關，太厲害了！<br><span style="font-size:0.8em; color:#00d2ff">花費時間: ${finalTime}</span>`;
                        statusDisplay.style.color = "#00ff00";
                    }
                }
            }
        }

        // --- 幽靈 AI 核心 (進階版) ---
        function updateGhosts() {
            if (gameOver || gameWin) return;

            const isPowerMode = Date.now() < powerModeEndTime;
            if (!isPowerMode && statusDisplay.innerText.includes("無敵模式")) {
                statusDisplay.innerText = ""; // 清除狀態文字
            }

            ghosts.forEach(g => {
                // 1. 處理死亡狀態
                if (g.isDead) {
                    if (Date.now() > g.reviveTime) {
                        g.isDead = false;
                        g.x = g.startX;
                        g.y = g.startY;
                        g.state = 'wander';
                        g.color = g.originalColor; // 恢復原色
                    } else {
                        return; // 死亡期間不移動
                    }
                }

                // 2. 狀態更新與顏色/速度設定
                if (isPowerMode) {
                    g.state = 'scared';
                    g.color = COLORS.ghostScared;
                } else {
                    g.color = g.originalColor;
                    // 如果無敵模式剛結束，重置為漫遊，之後再由距離判斷是否追擊
                    if (g.state === 'scared') g.state = 'wander'; 
                }

                // 計算實際移動速度
                let currentSpeed = g.speed;
                if (g.state === 'scared') currentSpeed *= 0.5; // 無敵模式速度變慢

                const gridX = Math.round(g.x / GRID_SIZE - 0.5);
                const gridY = Math.round(g.y / GRID_SIZE - 0.5);
                
                const centerX = gridX * GRID_SIZE + GRID_SIZE/2;
                const centerY = gridY * GRID_SIZE + GRID_SIZE/2;

                const nextX = g.x + g.dx * currentSpeed;
                const nextY = g.y + g.dy * currentSpeed;

                let crossCenter = false;
                if (g.dx !== 0) {
                    if ((g.x <= centerX && nextX >= centerX) || (g.x >= centerX && nextX <= centerX)) crossCenter = true;
                } else if (g.dy !== 0) {
                    if ((g.y <= centerY && nextY >= centerY) || (g.y >= centerY && nextY <= centerY)) crossCenter = true;
                } else {
                    crossCenter = true;
                }

                if (crossCenter) {
                    g.x = centerX;
                    g.y = centerY;

                    const possibleMoves = [];
                    const directions = [
                        { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                        { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                    ];

                    directions.forEach(dir => {
                        if (dir.dx === -g.dx && dir.dy === -g.dy) return; 
                        if (!isWallGrid(gridX + dir.dx, gridY + dir.dy)) possibleMoves.push(dir);
                    });

                    if (possibleMoves.length === 0) {
                        directions.forEach(dir => {
                            if (!isWallGrid(gridX + dir.dx, gridY + dir.dy)) possibleMoves.push(dir);
                        });
                    }

                    // 判斷一般狀態下的追擊/漫遊
                    if (!isPowerMode) {
                        const distToPacman = Math.hypot(g.x - pacman.x, g.y - pacman.y);
                        g.state = (distToPacman < ghostDetectionRadius) ? 'chase' : 'wander';
                    }

                    let bestMove = possibleMoves[0];

                    if (possibleMoves.length > 0) {
                        if (g.state === 'chase') {
                            // 追擊：找距離最短
                            let minDistance = Infinity;
                            possibleMoves.forEach(move => {
                                const nextGX = (gridX + move.dx) * GRID_SIZE + GRID_SIZE/2;
                                const nextGY = (gridY + move.dy) * GRID_SIZE + GRID_SIZE/2;
                                const d = Math.hypot(nextGX - pacman.x, nextGY - pacman.y);
                                if (d < minDistance) { minDistance = d; bestMove = move; }
                            });
                        } else if (g.state === 'scared') {
                            // ★ 逃跑演算法：找距離最長 (Flee Behavior)
                            let maxDistance = -1;
                            possibleMoves.forEach(move => {
                                const nextGX = (gridX + move.dx) * GRID_SIZE + GRID_SIZE/2;
                                const nextGY = (gridY + move.dy) * GRID_SIZE + GRID_SIZE/2;
                                const d = Math.hypot(nextGX - pacman.x, nextGY - pacman.y);
                                // 選擇離小精靈最遠的路
                                if (d > maxDistance) { maxDistance = d; bestMove = move; }
                            });
                        } else {
                            // 漫遊
                            bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        }
                    }

                    if (bestMove) {
                        g.dx = bestMove.dx;
                        g.dy = bestMove.dy;
                    }
                }

                g.x += g.dx * currentSpeed;
                g.y += g.dy * currentSpeed;

                // 碰撞檢測
                if (Math.hypot(g.x - pacman.x, g.y - pacman.y) < 20) {
                    if (g.state === 'scared') {
                        // 吃掉幽靈
                        g.isDead = true;
                        g.reviveTime = Date.now() + 5000; // 消失5秒
                        score += 10;
                        scoreDisplay.innerText = score;
                        // 讓幽靈暫時移出畫面 (或單純不畫)
                        g.x = -1000; 
                        g.y = -1000;
                    } else {
                        // Game Over
                        gameOver = true;
                        statusDisplay.innerText = "Game Over";
                        statusDisplay.style.color = "#ff4d4d";
                    }
                }
            });
        }

        // --- 繪圖系統 ---
        function drawMaze() {
            ctx.lineWidth = 2;
            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[r].length; c++) {
                    const x = c * GRID_SIZE;
                    const y = r * GRID_SIZE;
                    
                    if (maze[r][c] === 1) {
                        ctx.fillStyle = COLORS.wall;
                        ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = COLORS.wallBorder;
                        ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    } else if (maze[r][c] === 2) {
                        // 普通豆子
                        ctx.beginPath();
                        ctx.arc(x + GRID_SIZE/2, y + GRID_SIZE/2, 3, 0, Math.PI*2);
                        ctx.fillStyle = COLORS.pellet;
                        ctx.fill();
                    } else if (maze[r][c] === 3) {
                        // ★ 無敵星星 (繪製星形)
                        const cx = x + GRID_SIZE/2;
                        const cy = y + GRID_SIZE/2;
                        const spikes = 5;
                        const outerRadius = 8;
                        const innerRadius = 4;
                        
                        ctx.save();
                        ctx.translate(cx, cy);
                        // 讓星星旋轉
                        ctx.rotate((Date.now() / 200) % (Math.PI * 2));
                        ctx.beginPath();
                        for(let i=0; i<spikes*2; i++){
                            const r = (i%2 === 0) ? outerRadius : innerRadius;
                            const currAngle = (i * Math.PI) / spikes;
                            ctx.lineTo(Math.cos(currAngle)*r, Math.sin(currAngle)*r);
                        }
                        ctx.closePath();
                        ctx.fillStyle = COLORS.powerPellet;
                        ctx.shadowColor = COLORS.powerPellet;
                        ctx.shadowBlur = 10;
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.save();
            ctx.translate(pacman.x, pacman.y);
            
            let angle = 0;
            if (pacman.dx === 1) angle = 0;
            else if (pacman.dx === -1) angle = Math.PI;
            else if (pacman.dy === -1) angle = -Math.PI/2;
            else if (pacman.dy === 1) angle = Math.PI/2;
            
            pacman.angle = angle;
            ctx.rotate(angle);

            pacman.mouthOpen += pacman.mouthSpeed;
            if (pacman.mouthOpen > 0.25 * Math.PI || pacman.mouthOpen < 0) pacman.mouthSpeed *= -1;

            ctx.beginPath();
            ctx.arc(0, 0, pacman.radius, pacman.mouthOpen, 2 * Math.PI - pacman.mouthOpen);
            ctx.lineTo(0, 0);
            ctx.fillStyle = COLORS.pacman;
            ctx.shadowColor = COLORS.pacman;
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.restore();
        }

        function drawGhosts() {
            ghosts.forEach(g => {
                if (g.isDead) return; // 死亡不繪製

                ctx.save();
                ctx.translate(g.x, g.y);
                
                // 畫感知範圍 (如果是追擊狀態且不是逃跑狀態)
                if (g.state === 'chase' && !statusDisplay.innerText.includes("無敵模式")) {
                    ctx.beginPath();
                    ctx.arc(0, 0, ghostDetectionRadius, 0, Math.PI*2);
                    ctx.strokeStyle = g.color;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillStyle = g.color;
                ctx.shadowColor = g.color;
                ctx.shadowBlur = 20;

                ctx.beginPath();
                ctx.arc(0, 0, 12, Math.PI, 0);
                ctx.lineTo(12, 12);
                for(let i=1; i<=3; i++) {
                    ctx.lineTo(12 - 8*i, 12 - (i%2)*4);
                }
                ctx.fill();

                // 眼睛
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                const eyeOffsetX = g.dx * 3;
                const eyeOffsetY = g.dy * 3;
                
                ctx.beginPath();
                ctx.arc(-4 + eyeOffsetX, -2 + eyeOffsetY, 3, 0, Math.PI*2);
                ctx.arc(4 + eyeOffsetX, -2 + eyeOffsetY, 3, 0, Math.PI*2);
                ctx.fill();
                
                // 瞳孔
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-4 + eyeOffsetX*1.5, -2 + eyeOffsetY*1.5, 1.5, 0, Math.PI*2);
                ctx.arc(4 + eyeOffsetX*1.5, -2 + eyeOffsetY*1.5, 1.5, 0, Math.PI*2);
                ctx.fill();

                // 驚嚇表情 (如果是在無敵模式下，嘴巴變成波浪線)
                if (g.state === 'scared') {
                     ctx.strokeStyle = '#fff';
                     ctx.lineWidth = 1.5;
                     ctx.beginPath();
                     ctx.moveTo(-6, 6);
                     ctx.lineTo(-3, 4);
                     ctx.lineTo(0, 6);
                     ctx.lineTo(3, 4);
                     ctx.lineTo(6, 6);
                     ctx.stroke();
                }

                ctx.restore();
            });
        }

        function gameLoop() {
            ctx.fillStyle = COLORS.trail;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            updateTimer(); 
            drawMaze();
            updatePacman();
            updateGhosts();
            drawPacman();
            drawGhosts();

            animationId = requestAnimationFrame(gameLoop);
        }

        gameLoop();

    </script>
</body>
</html>