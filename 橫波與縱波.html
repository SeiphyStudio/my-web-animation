<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高中物理波動模擬實驗室 - Animation Master</title>
    <style>
        /* CSS reset & 基本設定 */
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #eeeeee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 上方畫布區 (70%) */
        #canvas-container {
            flex: 7;
            position: relative;
            width: 100%;
            background: #000;
            border-bottom: 2px solid #444;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 標籤覆蓋 */
        .overlay-label {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
            border-left: 4px solid #f1c40f; /* 黃色標示 */
        }
        .highlight { color: #f1c40f; font-weight: bold; }

        /* 下方控制區 (30%) */
        #controls {
            flex: 3;
            padding: 20px;
            background-color: #2c3e50;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
        }

        /* 控制群組 */
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }

        .control-group h3 { margin: 0 0 5px 0; font-size: 1rem; color: #3498db; }

        /* 滑桿樣式 */
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }
        
        .value-display { font-size: 0.9rem; color: #bdc3c7; text-align: right;}

        /* 按鈕樣式 */
        button {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .mode-btn { background-color: #7f8c8d; color: white; }
        .mode-btn.active { background-color: #f1c40f; color: black; transform: scale(1.05); }
        
        .action-btn { background-color: #27ae60; color: white; }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { background-color: #555; cursor: not-allowed; opacity: 0.6; }
        .stop-btn { background-color: #c0392b; color: white; }
        .pause-btn { background-color: #e67e22; color: white; }

        /* RWD 調整 */
        @media (max-width: 768px) {
            #controls { flex-direction: column; overflow-y: auto; }
            .control-group { width: 90%; }
        }
    </style>
</head>
<body>

    <!-- 畫布區 -->
    <div id="canvas-container">
        <canvas id="waveCanvas"></canvas>
        <div class="overlay-label">
            <h2>物理波動實驗室</h2>
            <p>模式: <span id="mode-name" class="highlight">橫波 (Transverse)</span></p>
            <p style="font-size: 0.8rem; color: #ddd;">黃色標記與綠色參考線用於觀察介質運動</p>
        </div>
    </div>

    <!-- 控制區 -->
    <div id="controls">
        
        <!-- 波動模式選擇 -->
        <div class="control-group">
            <h3>波動模式</h3>
            <div style="display: flex; gap: 5px;">
                <button class="mode-btn active" onclick="setMode('transverse')">橫波</button>
                <button class="mode-btn" onclick="setMode('longitudinal')">縱波</button>
            </div>
        </div>

        <!-- 參數調整 -->
        <div class="control-group">
            <h3>波源參數 (波速固定)</h3>
            
            <label>頻率 (Frequency) <span id="freq-val" class="value-display">0.30 Hz</span></label>
            <input type="range" id="freq-slider" min="0.1" max="0.5" step="0.05" value="0.3">
            
            <label>振幅 (Amplitude) <span id="amp-val" class="value-display">50 px</span></label>
            <input type="range" id="amp-slider" min="10" max="100" step="10" value="50">
        </div>

        <!-- 發波操作 -->
        <div class="control-group">
            <h3>發波操作</h3>
            <button class="action-btn" id="pulse-btn" onclick="triggerPulse()">發送單一脈衝 (Pulse)</button>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                <input type="checkbox" id="continuous-check" style="width: 20px; height: 20px;">
                <label for="continuous-check" style="cursor: pointer;">連續週期波 (Periodic)</label>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="pause-btn" id="pause-btn" onclick="togglePause()">暫停 (Pause)</button>
                <button class="stop-btn" onclick="resetWave()">重置 (Reset)</button>
            </div>
        </div>

    </div>

    <script>
        // --- 1. 變數宣告與初始化 ---
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        
        // 物理參數
        let frequency = 0.3;
        let amplitude = 50;
        const waveSpeed = 100; // pixels per second
        
        // 模擬狀態
        let currentMode = 'transverse'; 
        let isContinuous = false;
        let isPaused = false;
        let pulseQueue = []; 
        let time = 0;
        let lastTime = 0;

        // 連續波的相位控制變數
        let waveStartTime = 0;

        // 歷史緩衝區
        const MAX_HISTORY = 4000;
        let sourceHistory = new Float32Array(MAX_HISTORY);
        
        // 監聽器與 DOM 元素
        const freqSlider = document.getElementById('freq-slider');
        const ampSlider = document.getElementById('amp-slider');
        const continuousCheck = document.getElementById('continuous-check');
        const modeNameDisplay = document.getElementById('mode-name');
        const pulseBtn = document.getElementById('pulse-btn');
        const pauseBtn = document.getElementById('pause-btn');
        
        // --- 2. 事件監聽 ---
        
        window.addEventListener('resize', resizeCanvas);
        
        freqSlider.addEventListener('input', (e) => {
            frequency = parseFloat(e.target.value);
            document.getElementById('freq-val').innerText = frequency.toFixed(2) + " Hz";
        });

        ampSlider.addEventListener('input', (e) => {
            amplitude = parseFloat(e.target.value);
            document.getElementById('amp-val').innerText = amplitude + " px";
        });

        continuousCheck.addEventListener('change', (e) => {
            isContinuous = e.target.checked;
            pulseBtn.disabled = isContinuous; 
            
            // 重置波的起始時間，讓 sin 從 0 開始
            if (isContinuous) {
                waveStartTime = time;
            }
        });

        function resizeCanvas() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
        }

        // --- 3. 核心控制函數 ---

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const textMap = {
                'transverse': '橫波 (Transverse)',
                'longitudinal': '縱波 (Longitudinal)'
            };
            modeNameDisplay.innerText = textMap[mode];
            
            resetWave();
        }

        function triggerPulse() {
            if (isContinuous || isPaused) return; // 暫停時不能發脈衝
            const duration = 1.0 / frequency;
            pulseQueue.push({
                startTime: time,
                endTime: time + duration
            });
        }

        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.innerText = isPaused ? "繼續 (Resume)" : "暫停 (Pause)";
            pauseBtn.style.backgroundColor = isPaused ? "#27ae60" : "#e67e22"; // 綠色代表可以繼續，橘色代表可以暫停
        }

        function resetWave() {
            time = 0;
            pulseQueue = [];
            sourceHistory.fill(0);
            
            if (isContinuous) {
                waveStartTime = 0;
            }
            
            // 如果暫停中重置，保持暫停但清空畫面
            draw();
        }

        // --- 4. 物理運算引擎 ---

        function update(dt) {
            if (isPaused) return; // 暫停時停止更新物理狀態

            time += dt;
            
            let sourceY = 0;
            let isActive = false;
            const omega = 2 * Math.PI * frequency;

            if (isContinuous) {
                sourceY = Math.sin(omega * (time - waveStartTime));
                isActive = true;
            } else {
                for (let i = pulseQueue.length - 1; i >= 0; i--) {
                    const p = pulseQueue[i];
                    if (time >= p.startTime && time <= p.endTime) {
                        const localTime = time - p.startTime;
                        sourceY += Math.sin(omega * localTime); 
                        isActive = true;
                    } else if (time > p.endTime + (canvas.width/waveSpeed) + 2.0) {
                        pulseQueue.splice(i, 1);
                    }
                }
            }

            sourceHistory.copyWithin(1, 0); 
            sourceHistory[0] = isActive ? sourceY : 0;
        }

        // --- 5. 繪圖引擎 ---

        function draw() {
            ctx.fillStyle = '#000000'; // 黑底
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerY = canvas.height / 2;
            const startX = 50; 
            const maxPropagateX = canvas.width - startX;

            // 根據模式設定參數
            let pointSpacing = (currentMode === 'longitudinal') ? 20 : 5;
            
            const numPoints = Math.ceil(maxPropagateX / pointSpacing);
            // 標記點移到圖形中央
            const traceIndex = Math.floor(numPoints / 2);

            const dt_avg = 0.0166; 
            
            // 1. 繪製參考線 (最底層)
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#00ff00'; // 亮綠色
            ctx.beginPath();
            
            if (currentMode === 'transverse') {
                // 橫波：水平線 (全寬)
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
            } else if (currentMode === 'longitudinal') {
                // 縱波：
                // 黃色線條索引是 (traceIndex - 1)
                // 修正需求：綠色線條要向左移一格，也就是在 (traceIndex - 1) - 1 = traceIndex - 2 的位置
                const eqX = startX + (traceIndex - 2) * pointSpacing;
                
                // 繪製綠色線 (centerY +/- 120)
                ctx.moveTo(eqX, centerY - 120);
                ctx.lineTo(eqX, centerY + 120);
            }
            ctx.stroke();


            // 2. 繪製波形
            ctx.beginPath();

            // 橫波與縱波迴圈
            for (let i = 0; i < numPoints; i++) {
                const x = startX + i * pointSpacing;
                const dist = i * pointSpacing;
                const timeDelay = dist / waveSpeed;
                const historyIndex = Math.floor(timeDelay / dt_avg);

                let val = 0;
                if (historyIndex >= 0 && historyIndex < sourceHistory.length) {
                    val = sourceHistory[historyIndex];
                }

                if (currentMode === 'transverse') {
                    const yOffset = val * amplitude; 
                    const py = centerY - yOffset;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    if (i === 0) ctx.moveTo(x, py);
                    else ctx.lineTo(x, py);

                } else if (currentMode === 'longitudinal') {
                    const xOffset = val * amplitude * 0.8; 
                    const px = x + xOffset;
                    
                    // 黃色標記線索引：(traceIndex - 1)
                    // 這裡不變，黃色線條還是在它的位置
                    const isTrace = (i === (traceIndex - 1));
                    
                    ctx.strokeStyle = isTrace ? '#f1c40f' : '#ffffff'; 
                    ctx.lineWidth = isTrace ? 4 : 2; 
                    
                    ctx.stroke(); 
                    ctx.beginPath(); 
                    
                    // 黃色/白色線條長度 +/- 80 (總長160)
                    ctx.moveTo(px, centerY - 80); 
                    ctx.lineTo(px, centerY + 80);
                }
            }
            if (currentMode === 'transverse') ctx.stroke();
            

            // 3. 繪製質點與特殊標記 (上層)
            
            // --- 橫波質點 ---
            if (currentMode === 'transverse') {
                for (let i = 0; i < numPoints; i++) {
                    if (i % 4 !== 0 && i !== traceIndex) continue;
                    
                    const x = startX + i * pointSpacing;
                    const dist = i * pointSpacing;
                    const historyIndex = Math.floor((dist / waveSpeed) / dt_avg);
                    let val = (historyIndex >= 0 && historyIndex < sourceHistory.length) ? sourceHistory[historyIndex] : 0;
                    const py = centerY - (val * amplitude);

                    const isTrace = (i === traceIndex);
                    ctx.fillStyle = isTrace ? '#f1c40f' : '#ffffff';
                    let r = isTrace ? 8 : 4; 
                    
                    drawCircle(ctx, x, py, r);
                }
            }
        }

        function drawCircle(ctx, x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- 6. 主迴圈 ---

        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            const safeDt = Math.min(dt, 0.1);

            update(safeDt);
            draw();
            requestAnimationFrame(loop);
        }

        resizeCanvas();
        requestAnimationFrame(loop);

    </script>
</body>
</html>